/*
    Defined hardware I/O functions that the controller software needs to interface with.
    This includes MIDI I/O, foot-switch momentary toggle switches, and LED indicators
    above foot-switches.

    NOTE: it is expected that 'types.h' is #included before this file
*/

#include <stdbool.h>

extern void debug_log(const char *fmt, ...);

#define DEBUG_LOG0(fmt) debug_log(fmt)
#define DEBUG_LOG1(fmt, a1) debug_log(fmt,a1)
#define DEBUG_LOG2(fmt, a1, a2) debug_log(fmt,a1,a2)
#define DEBUG_LOG3(fmt, a1, a2, a3) debug_log(fmt,a1,a2,a3)

// --------------- Momentary toggle foot-switches and LEDs:

#define M_1 0x01U
#define M_2 0x02U
#define M_3 0x04U
#define M_4 0x08U
#define M_5 0x10U
#define M_6 0x20U
#define M_7 0x40U
#define M_8 0x80U

// --------------- MIDI I/O functions:

/* Send multi-byte MIDI commands
     0 <= cmd     <=  F   - MIDI command
     0 <= channel <=  F   - MIDI channel to send command to
    00 <= data1   <= FF   - first data byte of MIDI command
    00 <= data2   <= FF   - second (optional) data byte of MIDI command
*/
#define midi_send_cmd1(cmd, channel, data1) midi_send_cmd1_impl((((u8)cmd & (u8)0xF) << (u8)4) | ((u8)channel & (u8)0xF), (u8)data1)

extern void midi_send_cmd1_impl(u8 cmd_byte, u8 data1);

#define midi_send_cmd2(cmd, channel, data1, data2) midi_send_cmd2_impl((((u8)cmd & (u8)0xF) << (u8)4) | ((u8)channel & (u8)0xF), (u8)data1, (u8)data2)

extern void midi_send_cmd2_impl(u8 cmd_byte, u8 data1, u8 data2);

// Send a single byte for SysEx:
extern void midi_send_sysex(u8 byte);

// --------------- Flash memory functions:

// Flash addresses are 0-based where 0 is the first available byte of
// non-program flash memory.

// Load `count` bytes from flash memory at address `addr` into `data`:
extern void flash_load(u16 addr, u16 count, u8 *data);

// Stores `count` bytes from `data` into flash memory at address `addr`:
extern void flash_store(u16 addr, u16 count, u8 *data);

// Get a pointer to flash memory at address:
extern rom const u8 *flash_addr(u16 addr);

// --------------- Controller logic interface functions:

/* export */ extern void controller_init(void);

/* export */ extern bool controller_update(void);

void prev_scene(void);

void next_scene(void);

void reset_scene(void);

void prev_song(void);

void next_song(void);

void gain_set(int amp, u8 new_gain);

void volume_set(int amp, u8 new_volume);

void activate_program(int pr_idx);

void activate_song(int sl_idx);

void midi_invalidate(void);

void toggle_setlist_mode(void);

void tap_tempo(void);

void get_program_name(int pr_idx, char *name);

int get_set_list_program(int sl_idx);

enum amp_tone {
    AMP_TONE_CLEAN,
    AMP_TONE_DIRTY,
    AMP_TONE_ACOUSTIC,
    AMP_TONE_MAX
};

#define FX_COUNT 5
#define REPORT_PR_NAME_LEN 20

struct amp_report {
    // selected amp tone:
    enum amp_tone tone;

    // gain values for amp X/Y as MIDI [0, 127]:
    int gain[AMP_TONE_MAX];

    // volume boost/attenuation as MIDI [0, 127]:
    int volume;

    // which FX are enabled:
    bool fx_enabled[FX_COUNT];
    // MIDI CC numbers per FX:
    u8 fx_midi_cc[FX_COUNT];
};

// A read-only report structure generated by controller for UX:
struct report {
    // Program/Setlist mode switch:
    bool is_setlist_mode;

    // Program name:
    char pr_name[REPORT_PR_NAME_LEN];
    u8 tempo;

    // Is program modified in memory vs persisted copy:
    bool is_modified;

    // Program number
    int pr_val, pr_max;
    // Setlist position
    int sl_val, sl_max;
    // Scene number
    int sc_val, sc_max;

    // 2 amp reports:
    struct amp_report amp[2];
};

// Fill in an existing report structure with current state:
void report_fill(struct report *report);
